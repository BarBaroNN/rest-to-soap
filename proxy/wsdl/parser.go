package wsdl

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"go.uber.org/zap"
)

// Parser handles WSDL parsing and type information extraction
type Parser struct {
	client *http.Client
	logger *zap.Logger
	cache  map[string]interface{}
}

// NewParser creates a new WSDL parser
func NewParser(logger *zap.Logger) *Parser {
	return &Parser{
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
		logger: logger,
		cache:  make(map[string]interface{}),
	}
}

// GetTypeInfo retrieves type information from a WSDL URL
func (p *Parser) GetTypeInfo(url string) (map[string]interface{}, error) {
	// Check cache first
	if info, ok := p.cache[url]; ok {
		return info.(map[string]interface{}), nil
	}

	// Fetch WSDL
	resp, err := p.client.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Read WSDL content
	content, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// Parse WSDL
	var wsdl struct {
		XMLName xml.Name `xml:"definitions"`
		Types   struct {
			Schema []struct {
				ComplexTypes []struct {
					Name   string `xml:"name,attr"`
					Fields []struct {
						Name string `xml:"name,attr"`
						Type string `xml:"type,attr"`
					} `xml:"sequence>element"`
				} `xml:"complexType"`
			} `xml:"schema"`
		} `xml:"types"`
	}

	if err := xml.Unmarshal(content, &wsdl); err != nil {
		return nil, err
	}

	// Extract type information
	typeInfo := make(map[string]interface{})
	for _, schema := range wsdl.Types.Schema {
		for _, complexType := range schema.ComplexTypes {
			fields := make(map[string]string)
			for _, field := range complexType.Fields {
				fields[field.Name] = field.Type
			}
			typeInfo[complexType.Name] = fields
		}
	}

	// Cache the result
	p.cache[url] = typeInfo

	return typeInfo, nil
}

// ParseAndGenerate parses a WSDL URL and generates Go types
func (p *Parser) ParseAndGenerate(wsdlURL string) ([]byte, error) {
	// Check cache first
	if cached, ok := p.cache[wsdlURL]; ok {
		return cached.([]byte), nil
	}

	// Fetch WSDL
	wsdl, err := p.fetchWSDL(wsdlURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch WSDL: %w", err)
	}

	// Create temporary directory for gowsdl
	tmpDir, err := os.MkdirTemp("", "wsdl-*")
	if err != nil {
		return nil, fmt.Errorf("failed to create temp dir: %w", err)
	}
	defer os.RemoveAll(tmpDir)

	// Write WSDL to temp file
	wsdlFile := filepath.Join(tmpDir, "service.wsdl")
	if err := os.WriteFile(wsdlFile, wsdl, 0644); err != nil {
		return nil, fmt.Errorf("failed to write WSDL file: %w", err)
	}

	// Generate Go types using gowsdl
	output, err := p.generateTypes(wsdlFile, tmpDir)
	if err != nil {
		return nil, fmt.Errorf("failed to generate types: %w", err)
	}

	// Cache the result
	p.cache[wsdlURL] = output
	return output, nil
}

func (p *Parser) fetchWSDL(url string) ([]byte, error) {
	resp, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to fetch WSDL: %s", resp.Status)
	}

	return io.ReadAll(resp.Body)
}

func (p *Parser) generateTypes(wsdlFile, outputDir string) ([]byte, error) {
	// Run gowsdl
	cmd := exec.Command("gowsdl", "-o", filepath.Join(outputDir, "service.go"), wsdlFile)
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return nil, fmt.Errorf("gowsdl failed: %s: %w", stderr.String(), err)
	}

	// Read generated file
	output, err := os.ReadFile(filepath.Join(outputDir, "service.go"))
	if err != nil {
		return nil, fmt.Errorf("failed to read generated file: %w", err)
	}

	// Process the generated code
	processed, err := p.processGeneratedCode(output)
	if err != nil {
		return nil, fmt.Errorf("failed to process generated code: %w", err)
	}

	return processed, nil
}

func (p *Parser) processGeneratedCode(code []byte) ([]byte, error) {
	// Add package documentation
	doc := []byte(`// Code generated by rest-to-soap. DO NOT EDIT.
// This file contains types generated from WSDL definitions.

`)
	return append(doc, code...), nil
}
